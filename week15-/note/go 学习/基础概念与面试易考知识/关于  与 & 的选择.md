
---
疑问在于：`&` 是取地址运算符，那么为什么在函数签名中我们写 `func (c *client)` 而不是 `func (c &client)`？

这里涉及到 Go 语法的具体定义和函数参数声明的规则。

1.  **Go 语言函数参数的声明规则：**
    *   在 Go 语言中，函数的参数（包括方法接收器）声明使用的是**类型本身**，而不是表达式。
    *   当你需要一个指向 `client` 类型数据的指针时，你声明它的类型是 `*client`。这里的 `*` 是类型的一部分，表示“指向 `client` 类型”的指针类型。
    *   而 `&client` 是一个**表达式**，它在运行时用来获取一个 `client` 变量的地址，从而得到一个 `*client` 类型的值。但在函数签名中，我们声明的是**期望接收的参数的类型**，而不是如何获取这个参数的。

2.  **指针类型 `*client` 的本质：**
    *   `*client` 本身就是一个**独立的数据类型**。它表示的是一个内存地址，这个地址指向一块属于 `client` 类型的内存空间。
    *   当你定义一个函数参数为 `func SomeFunc(c *client)` 时，你是在声明：这个函数期望接收一个类型为“指向 client 的指针”的参数。

3.  **为什么不是 `func (c &client)`？**
    *   **`&client` 不是一个类型：** `&` 是一个操作符。在类型声明的上下文中，`client` 是类型名，`&` 是一个应用于变量的运算符，用于生成其地址。`&client` 本身并不能构成一个有效的类型名称。Go 的类型系统不允许在参数声明中使用这种“取地址操作符”作为类型的一部分。
    *   **类型是 `*client` (指针类型)，而不是 `&client` (取地址表达式)：** Go 将“指向某种类型的指针”作为一个**基础类型**来处理，并采用 `*` 前缀来表示这种类型。例如，如果 `T` 是一个类型，那么 `*T` 就是指向 `T` 的指针类型。

**类比理解：**

想象一下你在 C/C++ 中声明函数参数：

*   你声明一个函数不接受值，而是接受一个指向整型的指针，你会写 `void func(int* ptr)`。
*   你**不会**写 `void func(&int ptr)`，因为 `&int` 不是一个有效的类型声明。`&` 是在声明一个变量时，用来获取其地址的操作。

Go 语言在这方面是类似的。`*client` 是对 Go 类型系统的表述，它明确了我们期望接收的是一个 `client` 的指针。

**总结：**

*   **`*client`** 是一个**类型声明**，表示“指向 `client` 类型”的指针。
*   **`&`** 是一个**运行时运算符**，用于获取一个变量的地址，从而生成一个 `*client` 类型的值。
*   函数参数的声明需要使用**类型**，而不是**表达式**。因此，我们必须使用 `*client` 来表示参数是一个指向 `client` 的指针。
】
